#!/bin/bash

# This script is used for users sync after multi linux install on a single machine

# Determine program name
PRGDIR=`type $0 | awk '{print $3}'`
PRGNAME=`basename $0`
PRGNAME=`basename $0 |  awk -F '.' '{print $1}'`

# Get absolute path name of the script
PWD=`pwd`
DIRNAME=`dirname $0| sed 's/^\.//'`
LIB="$PWD/$DIRNAME"


# Define here the default values 
# Local group for shared users 
LOCALGROUP=local
LOCALGROUPID=10000
# This is the admin group GID
ADMINGROUP=admin
ADMINGID=120
# This is all groups that are assigned by defaults for shared users
ADMGROUPS="wheel vboxuser kvm $ADMINGROUP"
# User to sync 
# For now just one is supported
USERTOSYNC=
# share data FS name (need to have home directory directly in root of this FS, it will be mounted as /$DATAFS and need $DATAFS as label
DATAFS=data

# Users generic env dir and files
USERENVDIR=/data/env.d 
USERBASHRC=$USERENVDIR/bashrc

function usage {
cat << FIN
Create common settings on machine after fresh install 
usage : $PRGNAME
        -d : run in debug mode

Short explanations : 
It needs a device with label data to be mounted as /data 
/data/home dir will be linked to local /home 
Users will be created with referenced id and standard group called local 
admin group will be created and also admin user will receive $ADMGROUPS

FIN
}


function check_user() {
if [ ${USERTOSYNC:=NULL} == "NULL" ] ;
then 
	__print "ERROR" "USERTOSYNC not defined, exiting"
	exit
fi
}

function confirm() {
if [ $1 -ne 0 ]; 
then 
	shift
	__print "INPUT" "$*" 
	read __DUM
fi
}


function check_first ()  {
REZ=$(getent group $ADMINGROUP)
if [ $? -ne 0 ] ;
then
	__print "INFO" "$ADMINGROUP group do not exist $ADMINGROUP:$ADMINGID"
else
	REZ=$(echo $REZ | cut -d ':' -f 3)
	if [ ${REZ:=0} -ne $ADMINGID ];
	then
		__print "ERROR" "$ADMINGROUP  should be $ADMINGID but is $REZ , exiting"  
		exit 1
	fi
fi
}

# Print to std format, ignore output if SILENT env var is set to 1 
# First arg is LABEL 
# rest is message itself 
# printf "%-10s %-10s %-22s %-30s \n" "INFO :" "umounting filesystem" "$i" 

__print() {
if [ ${PRGNAME:=NULL} == "NULL" ] ; 
then
	echo "ERROR __print function exiting"
	exit 99
fi
local __label=$1 
shift
if [ ${SILENT:=0} -ne 1 ];
then
	printf "%-10s %-10s %-22s %-30s \n" "$PRGNAME : " "$__label : " "$*" 
	#echo $*
fi
}

amiroot() {
CMD=/usr/bin/whoami
if [ ! -x $CMD ];
then
	__print "ERROR" "cant get root status"
	exit 1 
else
	__DUM=$(/usr/bin/whoami)
	if [ ${__DUM:=NULL} == "root" ];
	then
		__print "INFO"  "You are root, continue"
	else
		__print "ERROR"  "Need to be root to run this"
		exit 1
	fi
fi
}

is_existing() {
local __SOURCE=$1 
shift
local __PARAM=$*
getent $__SOURCE $__PARAM > /dev/null 2>&1
RET=$?
echo $RET
return $RET
}

is_yes() {
local __PARAM
local __RET=1
local __STRING="Do you want to continue" 
[[ $# -ne 0 ]] && __STRING="$*"  
YES=(Y y )
__print "QUESTION"  "$__STRING (${YES[@]})"
read __PARAM 
for i in "${YES[@]}" ;
do
if [ "$i" == "$__PARAM" ]; 
then 
  #echo "$__PARAM found $i"
  __RET=0
  break 
#else
# echo "$__PARAM not found" 
fi
done 
#echo $__RET
return $__RET
}

build_datafs() { 
local __this
mount | egrep -w  /$DATAFS > /dev/null 2>&1 
if [ $? -eq 0 ];
then
	__this=$(mount | egrep -w  /$DATAFS  | cut -f 1 -d ' ')	
	__print "INFO"  "/$DATAFS mounted on $__this"
	return 1 
fi
[[ ! -d /$DATAFS ]] && mkdir /$DATAFS
egrep -w /$DATAFS /etc/fstab > /dev/null 2>&1
__this=$(blkid -L $DATAFS) 
if [ $? -ne 0 ];
then
	__print "ERROR"  "$DATAFS partition not found, create label like e2label partition data and run again"
	exit 1
fi

__print "INFO"  -n "Adding /$DATAFS (device is $__this) filesystem to fstab ?"
echo "$__this	/$DATAFS	ext4	defaults        0 2" >> /etc/fstab

mount /$DATAFS 
if [ $? -ne 0 ];
then	
	__print "ERROR"  "Error mounting $__this /$DATAFS"
	exit 1
fi
}


#Global vars
export SILENT=0

# Getopts 

while getopts dh sarg
do
case $sarg in
        d)      set -x
                DEBUG=1 ;;
        h)      usage
                end;;
        *)      echo "ERROR : $PRGNAME : Bad option or misusage"
                usage
                end ;;
esac
done

#main

amiroot
#check_user

# chromium-browser-chromium.desktop
# firefox thunderbird 
# git
# ncftp
# skrooge keepassx
# ibus anthy 
# firefox/iceweasel ... 
# utiliser puppet ?? 
# fsarchiver

PKGGET="urpmi" 
PKGCHK="urpmq --fuzzy"



# Package installation automation 
function pkgcmd {
CHECKLIST="apt-get yum equo urpmi"
CMDLIST=""
i=0 
for cmd in $(echo $CHECKLIST); 
do
which $cmd > /dev/null 2>&1
if [ $? -eq 0 ];
then
	i=$((i + 1))
	CMDLIST="$CMDLIST $cmd"
fi
if [ $i -eq 1 ];
then
	__print "INFO" "Package manager is $CMDLIST"
fi
done
}





findfamilly() {
local FTEST="dpkg urpmq yum zypper emerge"
local FAMILY="debian mandriva redhat zypper"

local FOUND=0
#declare -a FAMILY=('dmkg' 'urpmq' 'yum' 'zypper')
declare -A asso
asso=([dpkg]=debian [urpmq]=mandriva [yum]=redhat [zypper]=suse [emerge]=gentoo)

for i in $(echo $FTEST) ;
do
	which $i > /dev/null 2>&1 
	if [ $? -eq 0 ]; 
	then
		echo ${asso[$i]}
		FOUND=1
	fi
done
}

#echo ${PKGTYPE[1]} 

declare -a cmddebian=('dpkg -l' 'apt-cache search' 'apt-get update' 'apt-get upgrade' 'apt-get install')
declare -a cmdredhat=('rpm -ql' 'yum search' 'yum update' 'yum upgrade' 'yum install')
declare -a cmdsuse=('rpm -ql' 'zypper se' 'zypper up' 'zypper up' 'zypper in')
declare -a cmdmandriva=('uprmq' 'urpmq --fuzzy' 'urpmi -a' 'urmpi --auto-select' 'urpmi')
declare -a cmdgentoo=('equery f' 'eix' 'eix-sync' 'emerge -uNa' 'emerge -av')

# Application 
#APP="skrooge keepassx chromium-browser|chromium vlc rekonq"
APP="skrooge keepassx chromium-browser vlc rekonq"
SYS="git ncftp fsarchiver bumblebee"
LANG="ibus ibus-anthy"
OTHER="ttf-ubuntu-font-family"

THIS=$(findfamilly)
if [ ${THIS:=NULL} == 'NULL' ];
then
        echo 'no family'
	exit
else    
        echo "Familly is $THIS"
fi

case $THIS in 
	debian)	cmd=('dpkg -l' 'apt-cache search' 'apt-get update' 'apt-get upgrade' 'apt-get install') ;;
	redhat) cmd=('rpm -ql' 'yum search' 'yum update' 'yum upgrade' 'yum install') ;;
	suse)	cmd=('rpm -ql' 'zypper se' 'zypper up' 'zypper up' 'zypper in') ;;
	mandriva)	cmd=('uprmq' 'urpmq --fuzzy' 'urpmi -a' 'urmpi --auto-select' 'urpmi') ;;
	gentoo)	cmd=('equery f' 'eix -e' 'eix-sync' 'emerge -uNa' 'emerge -av') ;;
	*)	echo "family not up to date"
		exit ;;
esac


declare -A PKIN PKSE PKUP PKUG
PKIN=([debian]="dpkg -l" [redhat]="rpm -q" [suse]="rpm -q" [mandriva]="urpmq")
PKSE=([debian]="apt-cache search" [redhat]="yum search" [suse]="yum search" [mandriva]="urpmq --fuzzy")
PKUP=([debian]="apt-get update" [redhat]="yum update" [suse]="zypper up" [mandriva]="urpmi -a")
PKUG=([debian]="apt-get upgrade" [redhat]="yum upgrade" [suse]="zypper up" [mandriva]="urpmi --auto-select")

declare -a PK=("APP" "SYS" "LANG" "OTHER")
PKNB=${#PK[@]}

__print "INFO" "Updating package database"
eval $PKGUPD

LIST=""
for i in ${PK[@]}
do
	LIST="$LIST ${!i}"
	echo $LIST
	#eval $PKGUPD
	#echo $PKGUPD
done

for PKG in $LIST ;
do
	THIS=${cmd[1]}
	###DUMMY="${PKSE[$THIS]} $PKG"
	#__print "INFO" "searching $PKG"
	__print "INFO" "searching $THIS $PKG"
	#eval $DUMMY
done
